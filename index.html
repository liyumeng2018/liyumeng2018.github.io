<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/GBDT算法梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/GBDT算法梳理/" itemprop="url">GBDT算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-02T16:08:20+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GBDT(Gradient Boosting Decision Tree) 又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。  </p>
<h3 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h3><p>Adaboost算法的模型可认为是加法模型，加法模型的优化通常是一个复杂的优化问题，前向分布算法求解这一优化问题的思路是：<strong>从前往后每一步只学习一个基函数及其系数，逐步逼近优化目标函数。</strong><br><img src="https://upload-images.jianshu.io/upload_images/1667471-10debca340107bc0.png" alt="1"><br>这样，前向分布算法将同时求解从m=1到M的所有参数βm, rm的优化问题简化为逐次求解各个βm, rm的优化问题</p>
<h3 id="负梯度拟合"><a href="#负梯度拟合" class="headerlink" title="负梯度拟合"></a>负梯度拟合</h3><p>为了解决损失函数拟合方法的问题，Freidman提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。第t轮的第i个样本的损失函数的负梯度表示为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppjs3vjij30bc02jgli.jpg" alt="2"></p>
<p>利用(xi,rti)(i=1,2,..m),我们可以拟合一颗CART回归树，得到了第t颗回归树，其对应的叶节点区域Rtj,j=1,2,…,J。其中J为叶子节点的个数。<br>针对每一个叶子节点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的的输出值ctj如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppm9yyqej30c8036jrb.jpg" alt="7"><br>这样我们就得到了本轮的决策树拟合函数如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppne2d7gj308z02ot8k.jpg" alt="8"><br>从而本轮最终得到的强学习器的表达式如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppo3ktk8j30am01z3yd.jpg" alt="9"><br>通过损失函数的负梯度来拟合，我们找到了一种通用的拟合损失误差的办法，这样无轮是分类问题还是回归问题，我们通过其损失函数的负梯度的拟合，就可以用GBDT来解决我们的分类回归问题。区别仅仅在于损失函数不同导致的负梯度不同而已。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>对于分类算法，其损失函数一般有对数损失函数和指数损失函数两种:<br>a) 如果是指数损失函数，则损失函数表达式为     </p>
<p>L(y,f(x))=exp(−yf(x))  </p>
<p>b) 如果是对数损失函数，分为二元分类和多元分类两种。<br>  对于回归算法，常用损失函数有如下4种:<br>a)均方差，这个是最常见的回归损失函数<br>L(y,f(x))=(y−f(x))^2<br>b)绝对损失，这个损失函数也很常见<br>L(y,f(x))=|y−f(x)|<br>对应负梯度误差为：<br>sign(yi−f(xi))<br>c)Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqxxyebmj30ep026wei.jpg" alt="15">   </p>
<p>对应的负梯度误差为：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqyuqwfpj30fe031mx5.jpg" alt="16"><br>d) 分位数损失。它对应的是分位数回归的损失函数，表达式为<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0prdm1kl3j30g902lmx3.jpg" alt="17"><br> 其中θ为分位数，需要我们在回归前指定。对应的负梯度误差为：<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pretko4mj30a002e0sl.jpg" alt="18"><br> 对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>　输入是训练集样本,T={(x,y1),(x2,y2),…(xm,ym)},最大迭代次数T, 损失函数L。输出是强学习器f(x)<br> 初始化弱学习器<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppsadsjfj30at048gli.jpg" alt="8"><br> 对迭代轮数t=1,2,…T有：<br>a)对样本i=1,2，…m，计算负梯度<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppwft9vij30bc02f0sn.jpg" alt="9"><br>b)利用(xi,rti)(i=1,2,..m), 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为Rtj,j=1,2,…,J。其中J为回归树t的叶子节点的个数。<br>c) 对叶子区域j =1,2,..J,计算最佳拟合值<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqn6f56tj30d102ljra.jpg" alt="10"><br>d) 更新强学习器<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqnxqy4rj30c803n746.jpg" alt="11"><br>得到强学习器f(x)的表达式<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqocmpmbj30e102sa9z.jpg" alt="12"></p>
<h3 id="二分类，多分类"><a href="#二分类，多分类" class="headerlink" title="二分类，多分类"></a>二分类，多分类</h3><p>GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。<br>为了解决这个问题，主要有两个方法，一个是用指数损失函数，此时GBDT退化为Adaboost算法。另一种方法是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。本文仅讨论用对数似然损失函数的GBDT分类。而对于对数似然损失函数，我们又有二元分类和多元分类的区别。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqtxirz1j30o00git9z.jpg" alt="13"></p>
<p><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqv8lz5wj30ss0ocmz6.jpg" alt="14"><br>除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>针对GBDT正则化，我们通过子采样比例方法和定义步长v方法来防止过拟合。</p>
<p><strong>子采样比例:</strong> 通过不放回抽样的子采样比例（subsample），取值为(0,1]。如果取值为1，则全部样本都使用。如果取值小于1，利用部分样本去做GBDT的决策树拟合。选择小于1的比例可以减少方差，防止过拟合，但是会增加样本拟合的偏差。因此取值不能太低，推荐在[0.5, 0.8]之间。</p>
<p><strong>定义步长v:</strong> 针对弱学习器的迭代，我们定义步长v，取值为(0,1]。对于同样的训练集学习效果，较小的v意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：  </p>
<ol>
<li>相对少的调参时间情况下可以得到较高的准确率。  </li>
<li>可灵活处理各种类型数据，包括连续值和离散值，使用范围广。  </li>
<li>可使用一些健壮的损失函数，对异常值的鲁棒性较强，比如Huber损失函数。    </li>
</ol>
<p>缺点  </p>
<ol>
<li>弱学习器之间存在依赖关系，难以并行训练数据</li>
</ol>
<h3 id="sklearn参数"><a href="#sklearn参数" class="headerlink" title="sklearn参数"></a>sklearn参数</h3><p><strong>sklearn GBDT类库概述</strong></p>
<p>在sklearn中，Gradient Boosting Classifier为GBDT的分类类， 而Gradient Boosting Regressor为GBDT的回归类。两者的参数类型完全相同，当然有些参数比如损失函数loss的可选择项并不相同。这些参数中，类似于Adaboost，我们把重要参数分为两类，第一类是Boosting框架的重要参数，第二类是弱学习器即CART回归树的重要参数。</p>
<p><strong>GBDT类库boosting框架参数</strong></p>
<p>首先，我们来看boosting框架相关的重要参数。由于Gradient Boosting Classifier和Gradient Boosting Regressor的参数绝大部分相同，我们下面会一起来讲，不同点会单独指出。</p>
<p>1, n_estimators: 也就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</p>
<p>2, learning_rate: 即每个弱学习器的权重缩减系数<br>ν，也称作步长，在原理篇的正则化章节我们也讲到了，加上了正则化项，我们的强学习器的迭代公式为<br>fk(x)=fk−1(x)+νhk(x), ν的取值范围为0&lt;ν≤1.对于同样的训练集拟合效果，较小的<br>ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的ν开始调参，默认是1。</p>
<p>3, subsample: 即我们在原理篇的正则化章节讲到的子采样，取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。</p>
<p>4, init: 即我们的初始化的时候的弱学习器，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。</p>
<p>5, loss: 即我们GBDT算法中的损失函数。分类模型和回归模型的损失函数是不一样的。</p>
<blockquote>
<p>对于分类模型，有对数似然损失函数”deviance”和指数损失函数”exponential”两者输入选择。默认是对数似然损失函数”deviance”。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的”deviance”。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。</p>
</blockquote>
<blockquote>
<p>对于回归模型，有均方差”ls”, 绝对损失”lad”, Huber损失”huber”和分位数损失“quantile”。默认是均方差”ls”。一般来说，如果数据的噪音点不多，用默认的均方差”ls”比较好。如果是噪音点较多，则推荐用抗噪音的损失函数”huber”。而如果我们需要对训练集进行分段预测的时候，则采用“quantile”。</p>
</blockquote>
<p>6, alpha：这个参数只有Gradient  Boosting Regressor有，当我们使用Huber损失”huber”和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。<br><strong>GBDT类库弱学习器参数</strong></p>
<p>这里我们再对GBDT的类库弱学习器的重要参数做一个总结。由于GBDT使用了CART回归决策树，因此它的参数基本来源于决策树类，也就是说，和Decision Tree Classifier和Decision Tree Regressor的参数基本类似。<br>1, max_features: RF划分时考虑的最大特征数。可以使用很多种类型的值，默认是”None”,意味着划分时考虑所有的特征数；如果是”log2”意味着划分时最多考虑log2N个特征；如果是”sqrt”或者”auto”意味着划分时最多考虑N−−√N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数，其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。<br>2,max_depth:决策树最大深度。默认为”None”，决策树在建立子树的时候不会限制子树的深度这样建树时，会使每一个叶节点只有一个类别，或是达到min_samples_split。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。<br>3,min_samples_split:内部节点再划分所需最小样本数，默认2。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。<br>4, min_samples_leaf:叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。<br>5,min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。<br>6,max_leaf_nodes:最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。<br>7,min_impurity_split:节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点，即为叶子节点。一般不推荐改动默认值1e-7。<br>8,presort:是否对数据进行预分类，以加快拟合中最佳分裂点的发现。默认False，适用于大数据集。小数据集使用True,可以加快训练。是否预排序,预排序可以加速查找最佳分裂点，对于稀疏数据不管用，Bool，auto：非稀疏数据则预排序，若稀疏数据则不预排序<br>上面决策树参数中最重要的包括最大特征数max_features，最大深度max_depth，内部节点再划分所需最小样本数min_samples_split和叶子节点最少样本数min_samples_leaf。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>GBDT几乎可用于所有回归问题（线性/非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Ensemble-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/Ensemble-Learning/" itemprop="url">随机森林算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-01T10:37:43+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><p>机器学习中的一类方法，有时也被称为多分类器系统、基于委员会的学习。它对多个机器学习模型进行组合形成一个精度更高的模型，参与组合的模型称为弱学习器（weak learner,常指泛化性能略优于随机猜测的学习器，例如在二分类问题精度略高于50%的分类器）。在预测时使用弱学习器模型联合起来进行预测；训练时需要用训练样本集依次训练出这些弱学习器。典型的集成学习算法是随机森林和boosting算法，而AdaBoost算法是boosting算法的一种实现版本。</p>
<p>一般来说集成学习可以分为三大类：</p>
<ul>
<li>用于减少方差的bagging</li>
<li>用于减少偏差的boosting</li>
<li>用于提升预测结果的stacking</li>
</ul>
<p>集成学习方法也可以归为如下两大类：<br>串行集成方法，这种方法串行地生成基础模型（如AdaBoost）。串行集成的基本动机是利用基础模型之间的依赖。通过给错分样本一个较大的权重来提升性能。并行集成方法，这种方法并行地生成基础模型（如Random Forest）。并行集成的基本动机是利用基础模型的独立性，因为通过平均能够较大地降低误差。</p>
<h3 id="个体学习器"><a href="#个体学习器" class="headerlink" title="个体学习器"></a>个体学习器</h3><p>个体学习器通常是用一个现有的学习算法从训练数据产生，例如C4.5决策树算法、BP神经网络算法等。<br>集成中只包含同种类型的个体学习器，例如“决策树集成”中的个体学习器全是决策树，“神经网络集成”中就全是神经网络，这样的集成是“同质”（homogeneous）的，同质集成中的个体学习器也称为“基学习器”（base learner），相应的学习算法称为“基学习算法”（base learning algorithm）。</p>
<p>有同质就有异质（heterogeneous），若集成包含不同类型的个体学习器，例如同时包含决策树和神经网络，那么这时个体学习器一般不称为基学习器，而称作“组件学习器”（component leaner）或直接称为个体学习器。</p>
<p>要获得好的集成，<strong>个体学习器应“好而不同”</strong>，即个体学习器要有一定的准确性，即学习器不能太坏，并且要有“多样性”（diversity），即学习器间具有差异。</p>
<p>根据个体学习器生成方式的不同，目前集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表是Boosting，后者的代表是和Bagging和“随机森林”（Random Forest）。</p>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>Boosting是一族可将弱学习器提升为强学习器的算法。这一族算法的工作机制都是类似的：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最终将这T个基学习器进行加权结合。</p>
<p>Boosting族算法最著名的代表是 AdaBoost</p>
<p>Boosting算法要求基学习器对特定的数据分布进行学习，这一点是通过“重赋权法”（re-weighting）实现的，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重，对无法接受代全样本的基学习算法，则可通过“重采样法”（re-sampling）来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得到的样本集对基学习器进行训练。一般而言，这两种做法没有显著的优劣差别。不过由于Boosting算法在训练的每一轮都会检查当前生成的基学习器的性能是否比随机猜测好，若不符合则抛弃当前基学习器，并停止学习过程，这会导致最后的集成中只包含很少的基学习器而性能不佳。而若采用“重采样阀”，则可以获得“重启动”机会以避免训练过程的过早停止，即在抛弃不满足条件的当前基学习器之后，再根据当前分布重新对训练样本进行重采样，再基于新的采样结果重新训练出基学习器，从而使得学习过程可以持续到预设的T轮完成。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。（初始训练集中约有63.2%的样本出现在采样集中）</p>
<p>于是，我们可以采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再集成，这就是Bagging的基本流程。</p>
<p>在对预测输出进行结合时，Bagging通常对分类任务采用简单投票法，对回归任务使用简单平均法。若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者。</p>
<p>Boosting与Bagging 相比来说最大的区别就是 Boosting是串行的，而Bagging中所有的分类器是可以同时生成的，之间没有什么关系，而Boosting中则必须先生成第一个分类器，然后根据第一个分类器的结果生成第二个分类器，依次往后进行。</p>
<h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>集成学习的第二类模型，为了提高集成的泛化能力，每个基学习器之间不存在很强的依赖性，所以最终预测结果时，需要一定的策略对T个结果进行结合。下面介绍结合策略。</p>
<p>平均法</p>
<p>对数值型输出，最常见的结合策略是使用平均法。简单平均法加权平均法但是对于规模比较大的集成来说，权重参数比较多，较容易导致过拟合。加权平均法未必一定优于简单平均法。一般而言，在个体学习器性能相差较大时，宜使用加权平均法，而在个体学习器性能相近时，宜使用简单平均法。</p>
<p>投票法</p>
<p>绝对多数投票法:若某标记得票过半数，则预测为该标记；否则拒绝预测。</p>
<p>相对多数投票法:预测为得票最多的标记。若同时有多个标记获得最高票，则从中随机选取一个。</p>
<p>加权投票法</p>
<p>学习法:当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合。</p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林由多棵决策树组成，采用多棵决策树联合进行预测可以有效提高模型的精度。这些决策树用对训练样本集随机抽样构造出的样本集训练得到。由于训练样本集由随机抽样构造，因此称为随机森林。随机森林不仅对训练样本进行抽样，还对特征向量的分量随机抽样，在训练决策树时，每次寻找最佳分裂时只使用一部分抽样的特征分量作为候选特征进行分裂。</p>
<p>对于分类问题，一个测试样本会送到每一棵决策树中进行预测，然后进行投票，得票最多的类为最终分类结果。对于回归问题随机森林的预测输出是所有决策树输出的均值。例如随机森林有10棵决策树，有8课树的预测结果是第1类，1棵决策树的预测结果为第2类，2棵决策树的预测结果为第3类，则我们将样本判定成第1类。</p>
<p>将多个随机变量相加取均值，方差会减小。如果将每棵决策树的输出值看作随机变量，多棵树的输出值的均值的方差会比单棵树小，因此可以降低模型的方差。由于使用了决策树进行投票，而决策树是分段常数函数，因此随机森林也是分段常数函数，是一个非线性模型，而且是判别模型</p>
<p>包外误差</p>
<p>训练每一棵决策树时有一部分样本未参与训练，可以在训练时利用这些没有被选中的样本做测试，统计它们的预测误差，称为包外误差。这种做法与交叉验证类似。二者都是把样本集切分成多份，轮流用其中的一部分样本进行训练，用剩下的样本进行测试。不同的是交叉验证把样本均匀的切分成份，在训练集中同一个样本不会出现多次；后者在每次Bootstrap抽样时同一个样本可能会被选中多次。</p>
<p>计算变量的重要性</p>
<p>随机森林有一个特点，可以在训练过程中输出变量的重要性，即哪个特征分量对分类更有用。实现的方法是置换法。它的原理是，如果某个特征分量对分类很重要，那么改变样本的该特征分量的值，样本的预测结果就容易出现错误。也就是说这个特征值对分类结果很敏感。反之，如果一个特征对分类不重要，随便改变它对分类结果没多大影响。</p>
<p>对于分类问题，训练某决策树时在包外样本集中随机挑选两个样本，如果要计算某一变量的重要性，则置换这两个样本的这个特征值。统计置换前和置换后的分类准确率。变量重要性的计算公式为：</p>
<p>v=(置换之前正确分类的样本数−置换正确分类的样本数)/OOB样本总数</p>
<p>这反应的是置换前后的分类准确率变化值。</p>
<p>上面定义的是单棵决策树的变量重要性，计算出每棵树的变量重要性之后，对该值取平均就得到随机森林的变量重要性。计算出每个变量的重要性之后，将该值归一化得到最终的重要性值。</p>
<p>随机森林是一种判别模型，既支持分类问题，也支持回归问题，并且支持多分类问题。它是一种非线性模型，其预测函数为分段常数函数。</p>
<h3 id="随机森林的推广"><a href="#随机森林的推广" class="headerlink" title="随机森林的推广"></a>随机森林的推广</h3><p>extra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有：</p>
<p>1） 对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra trees一般不采用随机采样，即每个决策树采用原始训练集。</p>
<p>2） 在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。</p>
<p>从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是bias相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好</p>
<h3 id="随机森林优缺点"><a href="#随机森林优缺点" class="headerlink" title="随机森林优缺点"></a>随机森林优缺点</h3><p>优点</p>
<ul>
<li>所有的数据都能够有效利用，而且不用人为的分出一部分数据来做cross-validation；</li>
<li>随机森林可以实现很高的精确度，但是只有很少的参数，而且对于分类和回归都适用；</li>
<li>不用担心过拟合的问题；</li>
<li>不需要事先做特征选择，每次只用随机的选取几个特征来训练树。</li>
<li>随机森林算法能解决分类与回归两种类型的问题，表现良好，由于是集成学习，方差和偏差都比较低，泛化性能优越；</li>
<li>随机森林对于高维数据集的处理能力很好，它可以处理成千上万的输入变量，并确定最重要的变量，因此被认为是一个不错的降维方法。此外，该模型能够输出特征的重要性程度，这是一个非常实用的功能。</li>
<li>可以应对缺失数据</li>
<li>当存在分类不平衡的情况时，随机森林能够提供平衡数据集误差的有效方法</li>
<li>高度并行化，易于分布式实现f) 由于是树模型 ，不需要归一化即可之间使用</li>
</ul>
<p>缺点</p>
<ul>
<li>相比于其他算法，其输出预测可能较慢。</li>
<li>随机森林在解决回归问题时并没有像它在分类中表现的那么好，这是因为它并不能给出一个连续型的输出。当进行回归时，随机森林不能够作出超越训练集数据范围的预测，这可能导致在对某些还有特定噪声的数据进行建模时出现过度拟合。</li>
<li>对于许多统计建模者来说，随机森林给人的感觉像是一个黑盒子——你几乎无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试。</li>
<li>忽略属性之间的相关性</li>
</ul>
<p>sklearn 参数2    ​    </p>
<p>sklearn中决策树的参数：<br> <strong>1，criterion</strong>: ”gini” or “entropy”(default=”gini”)是计算属性的gini(基尼不纯度)还是entropy(信息增益)，来选择最合适的节点。</p>
<p> <strong>2，splitter</strong>: ”best” or “random”(default=”best”)随机选择属性还是选择不纯度最大的属性，建议用默认。</p>
<p> <strong>3，max_features</strong>: 选择最适属性时划分的特征不能超过此值。</p>
<p> 当为整数时，即最大特征数；当为小数时，训练集特征数*小数；<br> if “auto”, then max_features=sqrt(n_features).<br> If “sqrt”, thenmax_features=sqrt(n_features).<br> If “log2”, thenmax_features=log2(n_features).<br> If None, then max_features=n_features.</p>
<p> <strong>4，max_depth</strong>: (default=None)设置树的最大深度，默认为None，这样建树时，会使每一个叶节点只有一个类别，或是达到min_samples_split。</p>
<p> <strong>5，min_samples_split</strong>:根据属性划分节点时，每个划分最少的样本数。</p>
<p> <strong>6，min_samples_leaf</strong>:叶子节点最少的样本数。</p>
<p> <strong>7，max_leaf_nodes</strong>: (default=None)叶子树的最大样本数。</p>
<p> <strong>8，min_weight_fraction_leaf</strong>: (default=0) 叶子节点所需要的最小权值</p>
<p> <strong>9，verbose:</strong>(default=0) 是否显示任务进程</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>随机森林特有的参数：</p>
<p> <strong>1，n_estimators</strong>=10：决策树的个数，越多越好，但是性能就会越差，至少100左右（具体数字忘记从哪里来的了）可以达到可接受的性能和误差率。  </p>
<p> <strong>2，bootstrap</strong>=True：是否有放回的采样。  </p>
<p> <strong>3，oob_score</strong>=False：oob（out of  band，带外）数据，即：在某次决策树训练中没有被bootstrap选中的数据。多单个模型的参数训练，我们知道可以用cross  validation（cv）来进行，但是特别消耗时间，而且对于随机森林这种情况也没有大的必要，所以就用这个数据对决策树模型进行验证，算是一个简单的交叉验证。性能消耗小，但是效果不错。   </p>
<p> <strong>4，n_jobs</strong>=1：并行job个数。这个在集成算法中非常重要，尤其是bagging（而非boosting，因为boosting的每次迭代之间有影响，所以很难进行并行化），因为可以并行从而提高性能。1=不并行；n：n个并行；-1：CPU有多少core，就启动多少job。</p>
<p> <strong>5，warm_start</strong>=False：热启动，决定是否使用上次调用该类的结果然后增加新的。  </p>
<p> <strong>6，class_weight</strong>=None：各个label的权重。  </p>
<p>进行预测可以有几种形式：</p>
<p><strong>1，predict_proba</strong>(x)：给出带有概率值的结果。每个点在所有label的概率和为1.  </p>
<p><strong>2，predict</strong>(x)：直接给出预测结果。内部还是调用的predict_proba()，根据概率的结果看哪个类型的预测值最高就是哪个类型。  </p>
<p><strong>3，predict_log_proba</strong>(x)：和predict_proba基本上一样，只是把结果给做了log()处理</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>典型的应用包括各种图像和数据的分类，人脸检测与关键点定位问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
