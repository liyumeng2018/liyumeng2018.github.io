<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/XGB算法梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/XGB算法梳理/" itemprop="url">XGB算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-04T16:38:30+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CART树"><a href="#CART树" class="headerlink" title="CART树"></a>CART树</h2><p>分类回归树(classification and regression tree，CART)模型由Breiman等人在1984年提出，是应用广泛的决策树学习方法。CART同样由特征选择、树的生成以及剪枝组成，既可以用于分类也可以用于回归。同样属于决策树的一种。CART算法采用的是一种二分递归分割的技术，将当前样本分成两个子样本集，使得生成的非叶子节点都有两个分支。因此CART实际上是一颗二叉树。<br><strong>回归树的生成</strong><br>最小二乘法回归树生成算法<br>输入：训练数据集D<br>输出：回归树f(x)</p>
<p>在训练数据集所在的输入空间中，递归得将每一个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：  </p>
<p>(1)选择最优切分变量j和切分点s，求解<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qwsk6uhdj30k8037jrd.jpg" alt="1"><br>遍历变量j，对固定的切分变量j扫描切分点s，选择使上式达到误差最小的变量(j,s)，其中R1和R2表示的是划分之后的空间。<br>(2)用选定的(j,s)划分区域并决定响应的输出值。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qwucr2mfj30iw070glp.jpg" alt="2"><br>(3)继续对两个子区域调用步骤(1),(2),直到满足停止条件。<br>(4)将输入空间划分为M个区域R1,R2,R3….RM，生成决策树：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qwvij1jwj309w037t8k.jpg" alt="3"><br><strong>分类树的生成</strong><br>分类树是用基尼指数选择最优特征，同时决定该特征的最优二值切分点。<br>基尼指数<br>分类问题中，假设有K个类，样本点属于第K类的概率为Pk，则概率分布的基尼指数定义为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qx7ovgm3j3092039a9x.jpg" alt="4"><br>对于二分类问题来说，若样本点属于第一类的·概率为p，则概率分布的基尼指数为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qx8ynyj2j309c02pweb.jpg" alt="5"><br>对于给定的样本集合D，其基尼指数为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxa9ay8rj30a202ymx1.jpg" alt="6"><br>其中，Ck是D中属于第k类的样本子集，K是类的个数。|Ck|和D分别表示子集的个数和样本的个数。<br>如果样本集合D根据特征A是否取某一可能的值α被分割成D1和D2，即<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxcuvrzxj30fz02swec.jpg" alt="7"><br>所以在特征A的条件下集合D的基尼指数为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxdtar57j30fh02q747.jpg" alt="8"><br>其中基尼指数Gini(D)表示集合的不确定性，基尼指数G(D,A)表示A=a分解后集合的不决定性。基尼指数越大，样本集合的不确定性越大。<br><strong>分类树生成算法</strong><br>输入：训练数据集D,停止计算的条件<br>输出：CART决策树<br>具体步骤:<br>(1)计算现有特征对该数据集的基尼指数，对于每一个特征A，可以对样本点A是否为a可以将数据集D分成数据集D1,D2D1,D2。<br>(2)对于所有的特征A和所有可能的切分点a，选择基尼指数最小的特征以及相对应的切分点作为最优特征和最佳切分点。<br>(3)对最优子树递归调用(1)(2)，直到满足停止条件。<br>(4)生成CART分类树。    </p>
<p><strong>剪枝处理</strong></p>
<p>剪枝是决策树学习算法中对付过拟合的主要手段。主要是从已生成的书中剪掉一些子树或者叶子节点，并将根节点或者父节点作为新的叶子节点，从而简化分类树模型。决策树的剪枝往往是通过极小化决策树的整体损失函数或者代价函数。设树T的叶子节点数为|T|，叶子节点t上有Nt个样本点，其中k类的样本点数为Nkt，Ht(T)为结点t上的经验熵，αα&gt;=0为参数，所以损失函数定义为：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxh3xfv5j30u20gk0t7.jpg" alt="9"><br>C(T)表示对训练数据的预测误差，|T|表示模型的复杂度。损失函数其实正好表达了两者的平衡。</p>
<p>所以决策树生成的具体流程：</p>
<p>(1)计算每一个结点的经验熵Ta<br>(2)递归的从叶子节点开始往上遍历，减掉叶子节点，然后判断损失函数的值是否减少，如果减少，则将父节点作为新的叶子节点。<br>(3)重复(2)，直到完全不能剪枝。  </p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>（1）定义树的复杂度<br>对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxw8u7mkj30q90esq6h.jpg" alt="10"><br>定义这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的L2模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxx3yl5oj30kg045mya.jpg" alt="11"><br>这一个目标包含了TT个相互独立的单变量二次函数。我们可以定义<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxy3eckuj307y01d0sj.jpg" alt="12"><br>化简：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxzbgoemj30dy021aa1.jpg" alt="13"><br>求导：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qxzuhru7j303d01kmwx.jpg" alt="14"><br>代入最优解：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qy0iuxb3j306v0160sj.jpg" alt="15"><br>（2）打分函数计算示例<br>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)</p>
<p>（3）枚举不同树结构的贪心法<br>贪心法：每一次尝试去对已有的叶子加入一个分割<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qy1gh3xuj30he04ct9f.jpg" alt="16"><br>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有x &lt; a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQgy1g0qy278v2bj30lg081409.jpg" alt="17"><br>我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。<br>观察这个目标函数，会发现引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic（启发式）而进行的操作了。  </p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>和GBDT方法一样，XGBoost的提升模型也是采用残差，不同的是分裂结点选取的时候不一定是最小平方损失，其损失函数如下，较GBDT其根据树模型的复杂度加入了一项正则化项：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0qypdqmm3j30c9055aal.jpg" alt="19"></p>
<h2 id="分裂结点算法"><a href="#分裂结点算法" class="headerlink" title="分裂结点算法"></a>分裂结点算法</h2><p>1、暴力枚举  </p>
<p>2、近似方法 ，近似方法通过特征的分布，按照百分比确定一组候选分裂点，通过遍历所有的候选分裂点来找到最佳分裂点。<br> 两种策略：全局策略和局部策略。在全局策略中，对每一个特征确定一个全局的候选分裂点集合，就不再改变；而在局部策略中，每一次分裂 都要重选一次分裂点。前者需要较大的分裂集合，后者可以小一点。对比补充候选集策略与分裂点数目对模型的影响。 全局策略需要更细的分裂点才能和局部策略差不多<br>3、Weighted Quantile Sketch<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0qz5t6zutj30l709ajt5.jpg" alt="1"></p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>1）像Adaboost和GBDT中一样，对每一个模型乘以一个系数λ（0 &lt; λ ≤ 1），用来降低每个模型对结果的贡献<br>2）采用特征子采样方法，和RandomForest中的特征子采样一样，可以降低模型的方差  </p>
<h2 id="对缺失值处理"><a href="#对缺失值处理" class="headerlink" title="对缺失值处理"></a>对缺失值处理</h2><p>xgboost处理缺失值的方法和其他树模型不同。xgboost把缺失值当做稀疏矩阵来对待，本身的在节点分裂时不考虑的缺失值的数值。缺失值数据会被分到左子树和右子树分别计层损失，选择较优的那一个。如果训练中没有数据缺失，预测时出现了数据缺失，那么默认被分类到右子树。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0qylmcbqpj30cs0dc0y4.jpg" alt="18"><br>这样的处理方法固然巧妙，但也有风险：假设了训练数据和预测数据的分布相同，比如缺失值的分布也相同，不过直觉上应该影响不是很大。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>与GBDT相比，xgBoosting有以下进步：<br>1）GBDT以传统CART作为基分类器，而xgBoosting支持线性分类器，相当于引入L1和L2正则化项的逻辑回归（分类问题）和线性回归（回归问题）；<br>2）GBDT在优化时只用到一阶导数，xgBoosting对代价函数做了二阶Talor展开，引入了一阶导数和二阶导数；<br>3）当样本存在缺失值是，xgBoosting能自动学习分裂方向；<br>4）xgBoosting借鉴RF的做法，支持列抽样，这样不仅能防止过拟合，还能降低计算；<br>5）xgBoosting的代价函数引入正则化项，控制了模型的复杂度，正则化项包含全部叶子节点的个数，每个叶子节点输出的score的L2模的平方和。从贝叶斯方差角度考虑，正则项降低了模型的方差，防止模型过拟合；<br>6）xgBoosting在每次迭代之后，为叶子结点分配学习速率，降低每棵树的权重，减少每棵树的影响，为后面提供更好的学习空间；<br>7）xgBoosting工具支持并行,但并不是tree粒度上的，而是特征粒度，决策树最耗时的步骤是对特征的值排序，xgBoosting在迭代之前，先进行预排序，存为block结构，每次迭代，重复使用该结构，降低了模型的计算；block结构也为模型提供了并行可能，在进行结点的分裂时，计算每个特征的增益，选增益最大的特征进行下一步分裂，那么各个特征的增益可以开多线程进行；<br>8）可并行的近似直方图算法，树结点在进行分裂时，需要计算每个节点的增益，若数据量较大，对所有节点的特征进行排序，遍历的得到最优分割点，这种贪心法异常耗时，这时引进近似直方图算法，用于生成高效的分割点，即用分裂后的某种值减去分裂前的某种值，获得增益，为了限制树的增长，引入阈值，当增益大于阈值时，进行分裂；<br>然而，与LightGBM相比，又表现出了明显的不足：<br>1）xgBoosting采用预排序，在迭代之前，对结点的特征做预排序，遍历选择最优分割点，数据量大时，贪心法耗时，LightGBM方法采用histogram算法，占用的内存低，数据分割的复杂度更低；<br>2）xgBoosting采用level-wise生成决策树，同时分裂同一层的叶子，从而进行多线程优化，不容易过拟合，但很多叶子节点的分裂增益较低，没必要进行跟进一步的分裂，这就带来了不必要的开销；LightGBM采用深度优化，leaf-wise生长策略，每次从当前叶子中选择增益最大的结点进行分裂，循环迭代，但会生长出更深的决策树，产生过拟合，因此引入了一个阈值进行限制，防止过拟合.</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>跟决策树一样，多应用于分类问题<br>行业应用、业务优化  </p>
<h2 id="sklearn参数"><a href="#sklearn参数" class="headerlink" title="sklearn参数"></a>sklearn参数</h2><p>1）objective [ default=reg:linear ] 定义学习任务及相应的学习目标，可选的目标函数如下：<br>“reg:linear” –线性回归。<br>“reg:logistic” –逻辑回归。<br>“binary:logistic” –二分类的逻辑回归问题，输出为概率。<br>“binary:logitraw” –二分类的逻辑回归问题，输出的结果为wTx。<br>“count:poisson” –计数问题的poisson回归，输出结果为poisson分布。   在poisson回归中，max_delta_step的缺省值为0.7。(used to safeguard optimization)<br>“multi:softmax” –让XGBoost采用softmax目标函数处理多分类问题，同时需要设置参数num_class（类别个数）<br>“multi:softprob” –和softmax一样，但是输出的是ndata * nclass的向量，可以将该向量reshape成ndata 行nclass列的矩阵。没行数据表示样本所属于每个类别的概率。<br>“rank:pairwise” –set XGBoost to do ranking task by minimizing the pairwise loss<br>（2）’eval_metric’ The choices are listed below，评估指标:<br>“rmse”: root mean square error<br>“logloss”: negative log-likelihood<br>“error”: Binary classification error rate. It is calculated as #(wrong cases)/#(all cases). For the predictions, the evaluation will regard the instances with prediction value larger than 0.5 as positive instances, and the others as negative instances.<br>“merror”: Multiclass classification error rate. It is calculated as #(wrong cases)/#(all cases).<br>“mlogloss”: Multiclass logloss<br>“auc”: Area under the curve for ranking evaluation.<br>“ndcg”:Normalized Discounted Cumulative Gain<br>“map”:Mean average precision<br>“ndcg@n”,”map@n”: n can be assigned as an integer to cut off the top positions in the lists for evaluation.<br>“ndcg-“,”map-“,”ndcg@n-“,”map@n-“: In XGBoost, NDCG and MAP will evaluate the score of a list without any positive samples as 1. By adding “-” in the evaluation metric XGBoost will evaluate these score as 0 to be consistent under some conditions.<br>（3）lambda [default=0] L2 正则的惩罚系数<br>（4）alpha [default=0] L1 正则的惩罚系数<br>（5）lambda_bias 在偏置上的L2正则。缺省值为0（在L1上没有偏置项的正则，因为L1时偏置不重要）<br>（6）eta [default=0.3]<br>为了防止过拟合，更新过程中用到的收缩步长。在每次提升计算之后，算法会直接获得新特征的权重。 eta通过缩减特征的权重使提升计算过程更加保守。缺省值为0.3<br>取值范围为：[0,1]<br>（7）max_depth [default=6] 数的最大深度。缺省值为6 ，取值范围为：[1,∞]<br>（8）min_child_weight [default=1]<br>孩子节点中最小的样本权重和。如果一个叶子节点的样本权重和小于min_child_weight则拆分过程结束。在现行回归模型中，这个参数是指建立每个模型所需要的最小样本数。该成熟越大算法越conservative<br>取值范围为: [0,∞]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/GBDT算法梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/GBDT算法梳理/" itemprop="url">GBDT算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-02T16:08:20+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GBDT(Gradient Boosting Decision Tree) 又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。  </p>
<h3 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h3><p>Adaboost算法的模型可认为是加法模型，加法模型的优化通常是一个复杂的优化问题，前向分布算法求解这一优化问题的思路是：<strong>从前往后每一步只学习一个基函数及其系数，逐步逼近优化目标函数。</strong><br><img src="https://upload-images.jianshu.io/upload_images/1667471-10debca340107bc0.png" alt="1"><br>这样，前向分布算法将同时求解从m=1到M的所有参数βm, rm的优化问题简化为逐次求解各个βm, rm的优化问题</p>
<h3 id="负梯度拟合"><a href="#负梯度拟合" class="headerlink" title="负梯度拟合"></a>负梯度拟合</h3><p>为了解决损失函数拟合方法的问题，Freidman提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。第t轮的第i个样本的损失函数的负梯度表示为<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppjs3vjij30bc02jgli.jpg" alt="2"></p>
<p>利用(xi,rti)(i=1,2,..m),我们可以拟合一颗CART回归树，得到了第t颗回归树，其对应的叶节点区域Rtj,j=1,2,…,J。其中J为叶子节点的个数。<br>针对每一个叶子节点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的的输出值ctj如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppm9yyqej30c8036jrb.jpg" alt="7"><br>这样我们就得到了本轮的决策树拟合函数如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppne2d7gj308z02ot8k.jpg" alt="8"><br>从而本轮最终得到的强学习器的表达式如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppo3ktk8j30am01z3yd.jpg" alt="9"><br>通过损失函数的负梯度来拟合，我们找到了一种通用的拟合损失误差的办法，这样无轮是分类问题还是回归问题，我们通过其损失函数的负梯度的拟合，就可以用GBDT来解决我们的分类回归问题。区别仅仅在于损失函数不同导致的负梯度不同而已。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>对于分类算法，其损失函数一般有对数损失函数和指数损失函数两种:<br>a) 如果是指数损失函数，则损失函数表达式为     </p>
<p>L(y,f(x))=exp(−yf(x))  </p>
<p>b) 如果是对数损失函数，分为二元分类和多元分类两种。<br>  对于回归算法，常用损失函数有如下4种:<br>a)均方差，这个是最常见的回归损失函数<br>L(y,f(x))=(y−f(x))^2<br>b)绝对损失，这个损失函数也很常见<br>L(y,f(x))=|y−f(x)|<br>对应负梯度误差为：<br>sign(yi−f(xi))<br>c)Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqxxyebmj30ep026wei.jpg" alt="15">   </p>
<p>对应的负梯度误差为：<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqyuqwfpj30fe031mx5.jpg" alt="16"><br>d) 分位数损失。它对应的是分位数回归的损失函数，表达式为<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0prdm1kl3j30g902lmx3.jpg" alt="17"><br> 其中θ为分位数，需要我们在回归前指定。对应的负梯度误差为：<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pretko4mj30a002e0sl.jpg" alt="18"><br> 对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>　输入是训练集样本,T={(x,y1),(x2,y2),…(xm,ym)},最大迭代次数T, 损失函数L。输出是强学习器f(x)<br> 初始化弱学习器<br> <img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppsadsjfj30at048gli.jpg" alt="8"><br> 对迭代轮数t=1,2,…T有：<br>a)对样本i=1,2，…m，计算负梯度<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0ppwft9vij30bc02f0sn.jpg" alt="9"><br>b)利用(xi,rti)(i=1,2,..m), 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为Rtj,j=1,2,…,J。其中J为回归树t的叶子节点的个数。<br>c) 对叶子区域j =1,2,..J,计算最佳拟合值<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqn6f56tj30d102ljra.jpg" alt="10"><br>d) 更新强学习器<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqnxqy4rj30c803n746.jpg" alt="11"><br>得到强学习器f(x)的表达式<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqocmpmbj30e102sa9z.jpg" alt="12"></p>
<h3 id="二分类，多分类"><a href="#二分类，多分类" class="headerlink" title="二分类，多分类"></a>二分类，多分类</h3><p>GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。<br>为了解决这个问题，主要有两个方法，一个是用指数损失函数，此时GBDT退化为Adaboost算法。另一种方法是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。本文仅讨论用对数似然损失函数的GBDT分类。而对于对数似然损失函数，我们又有二元分类和多元分类的区别。<br><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqtxirz1j30o00git9z.jpg" alt="13"></p>
<p><img src="http://ww1.sinaimg.cn/large/005tJ8mQly1g0pqv8lz5wj30ss0ocmz6.jpg" alt="14"><br>除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>针对GBDT正则化，我们通过子采样比例方法和定义步长v方法来防止过拟合。</p>
<p><strong>子采样比例:</strong> 通过不放回抽样的子采样比例（subsample），取值为(0,1]。如果取值为1，则全部样本都使用。如果取值小于1，利用部分样本去做GBDT的决策树拟合。选择小于1的比例可以减少方差，防止过拟合，但是会增加样本拟合的偏差。因此取值不能太低，推荐在[0.5, 0.8]之间。</p>
<p><strong>定义步长v:</strong> 针对弱学习器的迭代，我们定义步长v，取值为(0,1]。对于同样的训练集学习效果，较小的v意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：  </p>
<ol>
<li>相对少的调参时间情况下可以得到较高的准确率。  </li>
<li>可灵活处理各种类型数据，包括连续值和离散值，使用范围广。  </li>
<li>可使用一些健壮的损失函数，对异常值的鲁棒性较强，比如Huber损失函数。    </li>
</ol>
<p>缺点  </p>
<ol>
<li>弱学习器之间存在依赖关系，难以并行训练数据</li>
</ol>
<h3 id="sklearn参数"><a href="#sklearn参数" class="headerlink" title="sklearn参数"></a>sklearn参数</h3><p><strong>sklearn GBDT类库概述</strong></p>
<p>在sklearn中，Gradient Boosting Classifier为GBDT的分类类， 而Gradient Boosting Regressor为GBDT的回归类。两者的参数类型完全相同，当然有些参数比如损失函数loss的可选择项并不相同。这些参数中，类似于Adaboost，我们把重要参数分为两类，第一类是Boosting框架的重要参数，第二类是弱学习器即CART回归树的重要参数。</p>
<p><strong>GBDT类库boosting框架参数</strong></p>
<p>首先，我们来看boosting框架相关的重要参数。由于Gradient Boosting Classifier和Gradient Boosting Regressor的参数绝大部分相同，我们下面会一起来讲，不同点会单独指出。</p>
<p>1, n_estimators: 也就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</p>
<p>2, learning_rate: 即每个弱学习器的权重缩减系数<br>ν，也称作步长，在原理篇的正则化章节我们也讲到了，加上了正则化项，我们的强学习器的迭代公式为<br>fk(x)=fk−1(x)+νhk(x), ν的取值范围为0&lt;ν≤1.对于同样的训练集拟合效果，较小的<br>ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的ν开始调参，默认是1。</p>
<p>3, subsample: 即我们在原理篇的正则化章节讲到的子采样，取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。</p>
<p>4, init: 即我们的初始化的时候的弱学习器，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。</p>
<p>5, loss: 即我们GBDT算法中的损失函数。分类模型和回归模型的损失函数是不一样的。</p>
<blockquote>
<p>对于分类模型，有对数似然损失函数”deviance”和指数损失函数”exponential”两者输入选择。默认是对数似然损失函数”deviance”。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的”deviance”。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。</p>
</blockquote>
<blockquote>
<p>对于回归模型，有均方差”ls”, 绝对损失”lad”, Huber损失”huber”和分位数损失“quantile”。默认是均方差”ls”。一般来说，如果数据的噪音点不多，用默认的均方差”ls”比较好。如果是噪音点较多，则推荐用抗噪音的损失函数”huber”。而如果我们需要对训练集进行分段预测的时候，则采用“quantile”。</p>
</blockquote>
<p>6, alpha：这个参数只有Gradient  Boosting Regressor有，当我们使用Huber损失”huber”和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。<br><strong>GBDT类库弱学习器参数</strong></p>
<p>这里我们再对GBDT的类库弱学习器的重要参数做一个总结。由于GBDT使用了CART回归决策树，因此它的参数基本来源于决策树类，也就是说，和Decision Tree Classifier和Decision Tree Regressor的参数基本类似。<br>1, max_features: RF划分时考虑的最大特征数。可以使用很多种类型的值，默认是”None”,意味着划分时考虑所有的特征数；如果是”log2”意味着划分时最多考虑log2N个特征；如果是”sqrt”或者”auto”意味着划分时最多考虑N−−√N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数，其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。<br>2,max_depth:决策树最大深度。默认为”None”，决策树在建立子树的时候不会限制子树的深度这样建树时，会使每一个叶节点只有一个类别，或是达到min_samples_split。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。<br>3,min_samples_split:内部节点再划分所需最小样本数，默认2。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。<br>4, min_samples_leaf:叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。<br>5,min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。<br>6,max_leaf_nodes:最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。<br>7,min_impurity_split:节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点，即为叶子节点。一般不推荐改动默认值1e-7。<br>8,presort:是否对数据进行预分类，以加快拟合中最佳分裂点的发现。默认False，适用于大数据集。小数据集使用True,可以加快训练。是否预排序,预排序可以加速查找最佳分裂点，对于稀疏数据不管用，Bool，auto：非稀疏数据则预排序，若稀疏数据则不预排序<br>上面决策树参数中最重要的包括最大特征数max_features，最大深度max_depth，内部节点再划分所需最小样本数min_samples_split和叶子节点最少样本数min_samples_leaf。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>GBDT几乎可用于所有回归问题（线性/非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Ensemble-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/Ensemble-Learning/" itemprop="url">随机森林算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-01T10:37:43+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><p>机器学习中的一类方法，有时也被称为多分类器系统、基于委员会的学习。它对多个机器学习模型进行组合形成一个精度更高的模型，参与组合的模型称为弱学习器（weak learner,常指泛化性能略优于随机猜测的学习器，例如在二分类问题精度略高于50%的分类器）。在预测时使用弱学习器模型联合起来进行预测；训练时需要用训练样本集依次训练出这些弱学习器。典型的集成学习算法是随机森林和boosting算法，而AdaBoost算法是boosting算法的一种实现版本。</p>
<p>一般来说集成学习可以分为三大类：</p>
<ul>
<li>用于减少方差的bagging</li>
<li>用于减少偏差的boosting</li>
<li>用于提升预测结果的stacking</li>
</ul>
<p>集成学习方法也可以归为如下两大类：<br>串行集成方法，这种方法串行地生成基础模型（如AdaBoost）。串行集成的基本动机是利用基础模型之间的依赖。通过给错分样本一个较大的权重来提升性能。并行集成方法，这种方法并行地生成基础模型（如Random Forest）。并行集成的基本动机是利用基础模型的独立性，因为通过平均能够较大地降低误差。</p>
<h3 id="个体学习器"><a href="#个体学习器" class="headerlink" title="个体学习器"></a>个体学习器</h3><p>个体学习器通常是用一个现有的学习算法从训练数据产生，例如C4.5决策树算法、BP神经网络算法等。<br>集成中只包含同种类型的个体学习器，例如“决策树集成”中的个体学习器全是决策树，“神经网络集成”中就全是神经网络，这样的集成是“同质”（homogeneous）的，同质集成中的个体学习器也称为“基学习器”（base learner），相应的学习算法称为“基学习算法”（base learning algorithm）。</p>
<p>有同质就有异质（heterogeneous），若集成包含不同类型的个体学习器，例如同时包含决策树和神经网络，那么这时个体学习器一般不称为基学习器，而称作“组件学习器”（component leaner）或直接称为个体学习器。</p>
<p>要获得好的集成，<strong>个体学习器应“好而不同”</strong>，即个体学习器要有一定的准确性，即学习器不能太坏，并且要有“多样性”（diversity），即学习器间具有差异。</p>
<p>根据个体学习器生成方式的不同，目前集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表是Boosting，后者的代表是和Bagging和“随机森林”（Random Forest）。</p>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>Boosting是一族可将弱学习器提升为强学习器的算法。这一族算法的工作机制都是类似的：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最终将这T个基学习器进行加权结合。</p>
<p>Boosting族算法最著名的代表是 AdaBoost</p>
<p>Boosting算法要求基学习器对特定的数据分布进行学习，这一点是通过“重赋权法”（re-weighting）实现的，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重，对无法接受代全样本的基学习算法，则可通过“重采样法”（re-sampling）来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得到的样本集对基学习器进行训练。一般而言，这两种做法没有显著的优劣差别。不过由于Boosting算法在训练的每一轮都会检查当前生成的基学习器的性能是否比随机猜测好，若不符合则抛弃当前基学习器，并停止学习过程，这会导致最后的集成中只包含很少的基学习器而性能不佳。而若采用“重采样阀”，则可以获得“重启动”机会以避免训练过程的过早停止，即在抛弃不满足条件的当前基学习器之后，再根据当前分布重新对训练样本进行重采样，再基于新的采样结果重新训练出基学习器，从而使得学习过程可以持续到预设的T轮完成。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。（初始训练集中约有63.2%的样本出现在采样集中）</p>
<p>于是，我们可以采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再集成，这就是Bagging的基本流程。</p>
<p>在对预测输出进行结合时，Bagging通常对分类任务采用简单投票法，对回归任务使用简单平均法。若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者。</p>
<p>Boosting与Bagging 相比来说最大的区别就是 Boosting是串行的，而Bagging中所有的分类器是可以同时生成的，之间没有什么关系，而Boosting中则必须先生成第一个分类器，然后根据第一个分类器的结果生成第二个分类器，依次往后进行。</p>
<h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>集成学习的第二类模型，为了提高集成的泛化能力，每个基学习器之间不存在很强的依赖性，所以最终预测结果时，需要一定的策略对T个结果进行结合。下面介绍结合策略。</p>
<p>平均法</p>
<p>对数值型输出，最常见的结合策略是使用平均法。简单平均法加权平均法但是对于规模比较大的集成来说，权重参数比较多，较容易导致过拟合。加权平均法未必一定优于简单平均法。一般而言，在个体学习器性能相差较大时，宜使用加权平均法，而在个体学习器性能相近时，宜使用简单平均法。</p>
<p>投票法</p>
<p>绝对多数投票法:若某标记得票过半数，则预测为该标记；否则拒绝预测。</p>
<p>相对多数投票法:预测为得票最多的标记。若同时有多个标记获得最高票，则从中随机选取一个。</p>
<p>加权投票法</p>
<p>学习法:当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合。</p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林由多棵决策树组成，采用多棵决策树联合进行预测可以有效提高模型的精度。这些决策树用对训练样本集随机抽样构造出的样本集训练得到。由于训练样本集由随机抽样构造，因此称为随机森林。随机森林不仅对训练样本进行抽样，还对特征向量的分量随机抽样，在训练决策树时，每次寻找最佳分裂时只使用一部分抽样的特征分量作为候选特征进行分裂。</p>
<p>对于分类问题，一个测试样本会送到每一棵决策树中进行预测，然后进行投票，得票最多的类为最终分类结果。对于回归问题随机森林的预测输出是所有决策树输出的均值。例如随机森林有10棵决策树，有8课树的预测结果是第1类，1棵决策树的预测结果为第2类，2棵决策树的预测结果为第3类，则我们将样本判定成第1类。</p>
<p>将多个随机变量相加取均值，方差会减小。如果将每棵决策树的输出值看作随机变量，多棵树的输出值的均值的方差会比单棵树小，因此可以降低模型的方差。由于使用了决策树进行投票，而决策树是分段常数函数，因此随机森林也是分段常数函数，是一个非线性模型，而且是判别模型</p>
<p>包外误差</p>
<p>训练每一棵决策树时有一部分样本未参与训练，可以在训练时利用这些没有被选中的样本做测试，统计它们的预测误差，称为包外误差。这种做法与交叉验证类似。二者都是把样本集切分成多份，轮流用其中的一部分样本进行训练，用剩下的样本进行测试。不同的是交叉验证把样本均匀的切分成份，在训练集中同一个样本不会出现多次；后者在每次Bootstrap抽样时同一个样本可能会被选中多次。</p>
<p>计算变量的重要性</p>
<p>随机森林有一个特点，可以在训练过程中输出变量的重要性，即哪个特征分量对分类更有用。实现的方法是置换法。它的原理是，如果某个特征分量对分类很重要，那么改变样本的该特征分量的值，样本的预测结果就容易出现错误。也就是说这个特征值对分类结果很敏感。反之，如果一个特征对分类不重要，随便改变它对分类结果没多大影响。</p>
<p>对于分类问题，训练某决策树时在包外样本集中随机挑选两个样本，如果要计算某一变量的重要性，则置换这两个样本的这个特征值。统计置换前和置换后的分类准确率。变量重要性的计算公式为：</p>
<p>v=(置换之前正确分类的样本数−置换正确分类的样本数)/OOB样本总数</p>
<p>这反应的是置换前后的分类准确率变化值。</p>
<p>上面定义的是单棵决策树的变量重要性，计算出每棵树的变量重要性之后，对该值取平均就得到随机森林的变量重要性。计算出每个变量的重要性之后，将该值归一化得到最终的重要性值。</p>
<p>随机森林是一种判别模型，既支持分类问题，也支持回归问题，并且支持多分类问题。它是一种非线性模型，其预测函数为分段常数函数。</p>
<h3 id="随机森林的推广"><a href="#随机森林的推广" class="headerlink" title="随机森林的推广"></a>随机森林的推广</h3><p>extra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有：</p>
<p>1） 对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra trees一般不采用随机采样，即每个决策树采用原始训练集。</p>
<p>2） 在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。</p>
<p>从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是bias相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好</p>
<h3 id="随机森林优缺点"><a href="#随机森林优缺点" class="headerlink" title="随机森林优缺点"></a>随机森林优缺点</h3><p>优点</p>
<ul>
<li>所有的数据都能够有效利用，而且不用人为的分出一部分数据来做cross-validation；</li>
<li>随机森林可以实现很高的精确度，但是只有很少的参数，而且对于分类和回归都适用；</li>
<li>不用担心过拟合的问题；</li>
<li>不需要事先做特征选择，每次只用随机的选取几个特征来训练树。</li>
<li>随机森林算法能解决分类与回归两种类型的问题，表现良好，由于是集成学习，方差和偏差都比较低，泛化性能优越；</li>
<li>随机森林对于高维数据集的处理能力很好，它可以处理成千上万的输入变量，并确定最重要的变量，因此被认为是一个不错的降维方法。此外，该模型能够输出特征的重要性程度，这是一个非常实用的功能。</li>
<li>可以应对缺失数据</li>
<li>当存在分类不平衡的情况时，随机森林能够提供平衡数据集误差的有效方法</li>
<li>高度并行化，易于分布式实现f) 由于是树模型 ，不需要归一化即可之间使用</li>
</ul>
<p>缺点</p>
<ul>
<li>相比于其他算法，其输出预测可能较慢。</li>
<li>随机森林在解决回归问题时并没有像它在分类中表现的那么好，这是因为它并不能给出一个连续型的输出。当进行回归时，随机森林不能够作出超越训练集数据范围的预测，这可能导致在对某些还有特定噪声的数据进行建模时出现过度拟合。</li>
<li>对于许多统计建模者来说，随机森林给人的感觉像是一个黑盒子——你几乎无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试。</li>
<li>忽略属性之间的相关性</li>
</ul>
<p>sklearn 参数2    ​    </p>
<p>sklearn中决策树的参数：<br> <strong>1，criterion</strong>: ”gini” or “entropy”(default=”gini”)是计算属性的gini(基尼不纯度)还是entropy(信息增益)，来选择最合适的节点。</p>
<p> <strong>2，splitter</strong>: ”best” or “random”(default=”best”)随机选择属性还是选择不纯度最大的属性，建议用默认。</p>
<p> <strong>3，max_features</strong>: 选择最适属性时划分的特征不能超过此值。</p>
<p> 当为整数时，即最大特征数；当为小数时，训练集特征数*小数；<br> if “auto”, then max_features=sqrt(n_features).<br> If “sqrt”, thenmax_features=sqrt(n_features).<br> If “log2”, thenmax_features=log2(n_features).<br> If None, then max_features=n_features.</p>
<p> <strong>4，max_depth</strong>: (default=None)设置树的最大深度，默认为None，这样建树时，会使每一个叶节点只有一个类别，或是达到min_samples_split。</p>
<p> <strong>5，min_samples_split</strong>:根据属性划分节点时，每个划分最少的样本数。</p>
<p> <strong>6，min_samples_leaf</strong>:叶子节点最少的样本数。</p>
<p> <strong>7，max_leaf_nodes</strong>: (default=None)叶子树的最大样本数。</p>
<p> <strong>8，min_weight_fraction_leaf</strong>: (default=0) 叶子节点所需要的最小权值</p>
<p> <strong>9，verbose:</strong>(default=0) 是否显示任务进程</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>随机森林特有的参数：</p>
<p> <strong>1，n_estimators</strong>=10：决策树的个数，越多越好，但是性能就会越差，至少100左右（具体数字忘记从哪里来的了）可以达到可接受的性能和误差率。  </p>
<p> <strong>2，bootstrap</strong>=True：是否有放回的采样。  </p>
<p> <strong>3，oob_score</strong>=False：oob（out of  band，带外）数据，即：在某次决策树训练中没有被bootstrap选中的数据。多单个模型的参数训练，我们知道可以用cross  validation（cv）来进行，但是特别消耗时间，而且对于随机森林这种情况也没有大的必要，所以就用这个数据对决策树模型进行验证，算是一个简单的交叉验证。性能消耗小，但是效果不错。   </p>
<p> <strong>4，n_jobs</strong>=1：并行job个数。这个在集成算法中非常重要，尤其是bagging（而非boosting，因为boosting的每次迭代之间有影响，所以很难进行并行化），因为可以并行从而提高性能。1=不并行；n：n个并行；-1：CPU有多少core，就启动多少job。</p>
<p> <strong>5，warm_start</strong>=False：热启动，决定是否使用上次调用该类的结果然后增加新的。  </p>
<p> <strong>6，class_weight</strong>=None：各个label的权重。  </p>
<p>进行预测可以有几种形式：</p>
<p><strong>1，predict_proba</strong>(x)：给出带有概率值的结果。每个点在所有label的概率和为1.  </p>
<p><strong>2，predict</strong>(x)：直接给出预测结果。内部还是调用的predict_proba()，根据概率的结果看哪个类型的预测值最高就是哪个类型。  </p>
<p><strong>3，predict_log_proba</strong>(x)：和predict_proba基本上一样，只是把结果给做了log()处理</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>典型的应用包括各种图像和数据的分类，人脸检测与关键点定位问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
